<compilation unit> : <import declarations>? <classes_objects>

<import declarations> : <import declaration> | <import declarations> <import declaration>

<import declaration> : import <type name> ;

<classes_objects> : <class_object> | <class_object> <classes_objects>

<class_object> : <class_declaration> | <object_declaration> | ;

<object_declaration> : object <identifier> <super>? { method_body }

<class_declaration> : class <identifier> <class_header> <super>? { <class body declarations>? }

<super> : extends <class type>

<class_header> : ( <formal parameter list>? )

<class body declarations> : <class body declaration> | <class body declarations> <class body declaration>

<class body declaration> : <field declaration> | <method declaration>

<formal parameter list> : <formal parameter> | <formal parameter list> , <formal parameter>

<formal parameter> : <variable declarator id> : <type> 

<class type> : <identifier> | with <identifier><class type>

<field declaration> :  val <variable declarator> ;

<variable declarator> : <identifier> | <identifier>: <type>   | <identifier> <variable_declarator_extra>  

<variable_declarator_extra> : = <variable initializer> | :<type> = <variable initializer>

<variable initializer> : <expression> 

<method declaration> : <method header> <method body>

<method header> : def <method declarator> : <type> = | def <method declarator> = 

<method declarator> : <identifier> ( <formal parameter list>? )

<method body> : <block> | ;

Types

<type> : <primitive type> | <reference type>
<primitive type> : <numeric type> | boolean

<numeric type> : <integral type> | <floating-point type>

<integral type> : byte | short | int | long | char

<floating-point type> : float | double

<reference type> : <class type> | <array type>

<class type> : <type name>

<array type> : Array

Blocks and Commands

<block> : { <block statements>? }
<block statements> : <block statement> | <block statements> <block statement>

<block statement> : <local variable declaration statement> | <statement>

<local variable declaration statement> : <local variable declaration> ;

<local variable declaration> : <type> <variable declarators>

<statement> : <statement without trailing substatement> | <if then statement> | <if then else statement> | <while statement> | <for statement>

<statement without trailing substatement> : <block> | <empty statement> | <expression statement> | <switch statement> | <break statement> | <continue statement> | <return statement>

<statement no short if> : <statement without trailing substatement> | <if then else statement no short if> 

<empty statement> : ;

<expression statement> : <statement expression> ;

<statement expression> : <assignment> | <preincrement expression> | <postincrement expression> | <predecrement expression> | <postdecrement expression> | <method invocation> | <class instance creation expression>

<if then statement>: if ( <expression> ) <statement>

<if then else statement>: if ( <expression> ) <statement no short if> else <statement>

<if then else statement no short if> : if ( <expression> ) <statement no short if> else <statement no short if>

<switch statement> : <expression>  match <switch block>

<switch block> : { <switch block statement groups>? <switch labels>? }

<switch block statement groups> : <switch block statement group> | <switch block statement groups> <switch block statement group>

<switch block statement group> : <switch labels> <block statements>

<switch labels> : <switch label> | <switch labels> <switch label>

<switch label> : case <expression> : | default :

<while statement> : while ( <expression> ) <statement>

for_loop = 'for' '{' for_exprs for_if_condition '}' statement
for_if_condition = ';' if_variables  for_if_condition | if_variables
if_variables = 'if' expression 
for_exprs =  for_variables ';' for_exprs | for_variables
for_variables = ID_VARNAME '<-' expression for_untilTo expression 
for_untilTo = 'until' | 'to'

<statement expression list> : <statement expression> | <statement expression list> , <statement expression>

<break statement> : break <identifier>? ;

<continue statement> : continue <identifier>? ;

<return statement> : return <expression>? ;


Expressions

<expression> : <assignment expression>

<assignment expression> : <conditional expression> | <assignment>

<assignment> : <left hand side> <assignment operator> <assignment expression>

<left hand side> : <expression name> | <array access>

<assignment operator> : = | *= | /= | %= | += | -= | <<= | >>= | >>>= | &= | ^= | |=

<conditional expression> : <conditional or expression> | <conditional or expression> ? <expression> : <conditional expression>

<conditional or expression> : <conditional and expression> | <conditional or expression> || <conditional and expression>

<conditional and expression> : <inclusive or expression> | <conditional and expression> && <inclusive or expression>

<inclusive or expression> : <exclusive or expression> | <inclusive or expression> | <exclusive or expression>

<exclusive or expression> : <and expression> | <exclusive or expression> ^ <and expression>

<and expression> : <equality expression> | <and expression> & <equality expression>

<equality expression> : <relational expression> | <equality expression> == <relational expression> | <equality expression> != <relational expression>

<relational expression> : <shift expression> | <relational expression> < <shift expression> | <relational expression> > <shift expression> | <relational expression> <= <shift expression> | <relational expression> >= <shift expression> | <relational expression> instanceof <reference type>

<shift expression> : <additive expression> | <shift expression> << <additive expression> | <shift expression> >> <additive expression>

<additive expression> : <multiplicative expression> | <additive expression> + <multiplicative expression> | <additive expression> - <multiplicative expression>

<multiplicative expression> : <unary expression> | <multiplicative expression> * <unary expression> | <multiplicative expression> / <unary expression> | <multiplicative expression> % <unary expression>

<cast expression> : ( <primitive type> ) <unary expression> 

<unary expression> :  + <unary expression> | - <unary expression> | <unary expression not plus minus>

<unary expression not plus minus> : <postfix expression> | ~ <unary expression> | ! <unary expression> | <cast expression>

<postfix expression> : <primary no new array> | <expression name> 

<method invocation> : <method name> ( <argument list>? ) | <primary no new array> . <identifier> ( <argument list>? ) 

<primary no new array> : <literal> | this | ( <expression> ) | <class instance creation expression> | <method invocation> | <array access>

<class instance creation expression> : new <class type> ( <argument list>? )

<argument list> : <expression> | <argument list> , <expression>

<array access> : <expression name> [ <expression> ]

Tokens we need

<package name> : <identifier> | <package name> . <identifier>

<type name> : <identifier> | <package name> . <identifier>

<simple type name> : <identifier>

<expression name> : <identifier> | <ambiguous name> . <identifier>

<method name> : <identifier> | <ambiguous name>. <identifier>

<ambiguous name>: <identifier> | <ambiguous name>. <identifier>

<literal> : <integer literal> | <floating-point literal> | <boolean literal> | <character literal> | <string literal> | <null literal>